// Generated by CoffeeScript 1.7.1
(function() {
  var LazyLet, asFn, bind, getter;

  bind = function(fn, self) {
    return function() {
      return fn.apply(self, arguments);
    };
  };

  asFn = function(valueOrFn) {
    if (typeof valueOrFn === 'function') {
      return valueOrFn;
    } else {
      return function() {
        return valueOrFn;
      };
    }
  };

  getter = function(obj, name, fn) {
    return Object.defineProperty(obj, name, {
      get: fn,
      configurable: true,
      enumerable: true
    });
  };

  LazyLet = {
    Env: function() {
      var Let, defineInBulk, defineOneVariable, env, funs, illegallyAccessedVariable, isStackOverflowError, memoize, memos, privateEnv, redefine, resetEnv, trapOuterEnvAccess, trapStackOverflow;
      privateEnv = {};
      env = {};
      funs = {};
      memos = {};
      illegallyAccessedVariable = void 0;
      resetEnv = function() {
        var name, _i, _len, _ref, _results;
        funs = {};
        memos = {};
        privateEnv = {};
        _ref = Object.keys(env);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          if (name !== 'Let') {
            _results.push(delete env[name]);
          }
        }
        return _results;
      };
      memoize = function(name, fn) {
        return function() {
          var memo;
          memo = memos[name];
          if (memo != null) {
            return memo;
          } else {
            return memos[name] = fn();
          }
        };
      };
      isStackOverflowError = function(err) {
        var message;
        message = (typeof err === 'string' ? err : err != null ? err.message : void 0) || '';
        return message.match(/\bstack|recursion\b/);
      };
      trapStackOverflow = function(name, fn) {
        return function() {
          var err;
          try {
            return fn();
          } catch (_error) {
            err = _error;
            if (isStackOverflowError(err)) {
              throw "recursive definition of variable '" + name + "' detected";
            } else {
              throw err;
            }
          }
        };
      };
      redefine = function(name, fn) {
        var newEnv, newFn, oldFn;
        newEnv = Object.create(privateEnv);
        oldFn = funs[name];
        getter(newEnv, name, bind(oldFn, privateEnv));
        newFn = bind(fn, newEnv);
        getter(privateEnv, name, newFn);
        return newFn;
      };
      trapOuterEnvAccess = function(name, fn) {
        return function() {
          illegallyAccessedVariable = name;
          try {
            return fn();
          } finally {
            illegallyAccessedVariable = void 0;
          }
        };
      };
      defineOneVariable = function(name, valueOrFn) {
        var fn, handler;
        if (name === 'Let') {
          throw 'cannot redefine Let';
        }
        memos = {};
        fn = asFn(valueOrFn);
        if (funs[name] != null) {
          fn = redefine(name, fn);
        } else {
          handler = memoize(name, trapOuterEnvAccess(name, trapStackOverflow(name, bind(fn, privateEnv))));
          getter(privateEnv, name, handler);
          getter(env, name, function() {
            if (illegallyAccessedVariable != null) {
              throw "illegal attempt to access the Let environment in the definition of '" + illegallyAccessedVariable + "'";
            } else {
              return privateEnv[name];
            }
          });
        }
        return funs[name] = fn;
      };
      defineInBulk = function(object) {
        var name, thing, _results;
        _results = [];
        for (name in object) {
          thing = object[name];
          _results.push(defineOneVariable(name, thing));
        }
        return _results;
      };
      Let = function() {
        var args, name, thing;
        args = [].slice.apply(arguments);
        if (typeof args[0] === 'object') {
          return defineInBulk(args[0]);
        } else {
          name = args[0], thing = args[1];
          return defineOneVariable(name, thing);
        }
      };
      Object.defineProperty(env, 'Let', {
        writable: false,
        configurable: false,
        value: Let
      });
      Object.defineProperties(Let, {
        clear: {
          writable: false,
          configurable: false,
          value: resetEnv
        }
      });
      return env;
    }
  };

  if ((typeof module !== 'undefined') && (module.exports != null)) {
    module.exports = LazyLet;
  } else {
    this.LazyLet = LazyLet;
  }

}).call(this);
